# Тестирование ПО

### Что такое тестирование 
Тестирование программного обеспечения — процесс исследования, испытания программного продукта, который подразумевает несколько целей: определение соответствия программы изначально предъявленным к ней требованиям; и выявить ситуации, в которых поведение программы является неправильным, нежелательным или не соответствующим спецификации.
Тестирование может быть: 
-	модульным (unit testing)
-	интеграционным (Integration testing)
-	системным

Модульное тестирование — тестирует минимально возможный для тестирования компонент, например, отдельный класс или функцию. Часто модульное тестирование осуществляется разработчиками программного обеспечения. 

Интеграционное тестирование — одна из фаз тестирования программного обеспечения, при которой отдельные программные модули объединяются и тестируются в группе. 

Системное тестирование — это тестирование программного обеспечения, выполняемое на полной, интегрированной системе, с целью проверки соответствия системы исходным требованиям. 

По степени автоматизации тестирование может быть ручными или автоматическим. 

Стоит учесть, что автоматическое тестирование происходит на собранном с специальными настройками приложении или библиотеке и запускается в особом окружении. Тесты требуют определенных затрат, как машинного ресурса (для работы программы-тестировщика), так и человеческого (время и силы на написание тестов). 


### Стоит ли писать тесты? 
Так стоит ли вообще писать тесты? Многие считают, что тесты не стоят того, так как они требуют дополнительного объем кода, на написание которого нужно тратить время. И эта мысль имеет право на существование, но она верна лишь отчасти. Для того, чтобы понять, нужны ли вам тесты, сначала необходимо определить, какое приложение вы разрабатываете. Если вы пишите сайт-визитку, то весь функционал такого приложения можно очень быстро протестировать вручную, а написание автоматических тестов не имеет смысла. Еще одним примером приложения, которое не следует тестировать, может являться программа, написанная для соревнований\выставки – код которой должен выполнять свою функцию лишь малый отрезок времени, а конфигурация железа и вспомогательного софта известна и неизменна.  Если же вы создаете большой и сложный проект, который в будущем будет развиваться и масштабироваться, то вам просто необходимы тесты. Но неужели весь-весь код стоит покрывают тестами? Ответ на этот вопрос – однозначно, нет. Если вы осознали нужду тестирования вашего проекта, то вторым шагом будет оценка самого кода. Тут стоит выделить 2 критерия: сложность и количество зависимостей. И в некоторых случаях все кристально ясно: любой сложный код тестируем, простой и без зависимостей – нет. А что делать с простым кодом, с большим количеством зависимостей? Такой код можно представить, как прослойку, которая связывает между собой различные библиотеки\модули, вызывая функции из одних и передавая результат в другие. Такой код также обязательно необходимо тестировать. И эту необходимость можно объяснить простым жизненным примером: причиной потери Mars Climate Orbiter 23 сентября 1999 года была программно-человеческая ошибка: одно подразделение проекта считало «в дюймах», а другое – «в метрах», и прояснилось это уже после потери аппарата. Плачевного результата можно было бы избежать, если бы были протестированы «швы» приложения.

Сделаем небольшой вывод: к тестам стоит прибегать тогда, когда ваш проект сложен и имеет множество зависимостей, и вы планируете его развивать и поддерживать в дальнейшем.

### Важность тестирования

Проект не покрытый тестами, как правило пестрит плохим кодом. При этом, как работает каждый модуль в этом проекте в отдельности, знает только сам автор кода, и то не факт, что он сможет разобраться в своем же коде, например, через год. Поэтому помимо того, что тесты выполняют свою прямую функцию - позволяют проверять соответствие кода требованиям, они как побочный эффект «выпрямляют» дизайн классов. Все потому, что на класс с «кривым» дизайном тесты не напишешь, следовательно, чтобы добиться тестируемость приходится изменять класс. Либо, если тесты пишутся до кода, дизайн класса сразу рождается правильным. Тестируемый код является переиспользуемым, т.к. он уже протестирован, а значит работает ровно так, как этого от него ожидают. Так же тесты, возможно, но совсем не обязательно, улучшат архитектуру приложения в целом. Можно сказать, что дизайн класса хорош ровно настолько, насколько данный класс можно протестировать с помощью unit тестов.

Проект покрытый тестами (а это так же значит, что он написан красиво и понятно) имеет следующие преимущества:
-	любой новый разработчик может очень быстро присоединиться к проекту, потратив мало времени на погружение (понимание)
-	поломка какой-либо старой функциональности из-за появления новой может быть быстро обнаружена на этапе тестирования, что позволяет избежать появления неожиданных багов у конечного пользователя
-	есть уверенность в работоспособности целого приложения в любой момент времени

Если долгосрочный проект не покрывать тестами, то рано или поздно встанет нужда переписать его с нуля!

### Требования к тест-коду

Многие неопытные разработчики полагают, что в тестах допустимо все.  Они считают, что DRY (“Don’t repeat yourself”), KISS (“Keep it short and simple”) и все остальное – это для продакшна. Это не верно. Тесты – такой же код. Не относитесь к ним как к второсортному коду. Разница только в том, что у тестов другая цель – обеспечить качество вашего приложения. Все принципы, применяемые в разработке продакшн-кода могут и должны применяться при написании тестов.

Кроме того, тесты должны соответствовать следующим требованиям:
-	Быть достоверными
-	Не зависеть от окружения, на котором они выполняются
-	Легко поддерживаться, читаться и быть простыми для понимания
-	Запускаться регулярно в автоматическом режиме
-	Тестировать каждый отдельный функционал в отдельности

Если пренебрегать этими требованиями, то тесты не только могут стать бесполезными для проекты, но даже более того – станут ему вредить, т.к. объем плохого кода (который тоже время от времени приходится поддерживать) увеличится.

### Анти-патерны программирования
Как уже было установлено: для того, чтобы тестировать код, необходимо, чтобы он был правильно написан. Поэтому рассмотрим основы того, как НЕ надо писать код. 

#### Программирование копи-пастом (Copy and Paste Programming)
Часто на практике случается, что какой-то новый функционал имеет схожую реализацию с уже имеющимся. И самое простое, что может сделать разработчик – это скопировать имеющийся код и внести в него некоторые изменения. Но из-за этого появляется сразу несколько проблем. Если в изначальном коде была ошибка, то она так же скопируется и в новое место, а тогда, когда ее обнаружат - исправят лишь в одном месте, т.к. о существовании точно такого же кода никто не будет знать. Аналогичные рассуждения так же подходят и для случая, когда в данном функционале понадобится что-то изменить – его придется править во всех местах, которые еще нужно будет найти. Вне зависимости от того, был ли покрыт тестами старый код, для нового придется писать их по новой (скорее всего это так же будет сделано копированием уже имеющихся). Все это неуклонно ведет к появлению багов. 

**Пример:**

*Некорректный код:*
```
class Some
{
    public void AddImgTagForAllFiles(string folderPath)
    {
        foreach (var f in Directory.GetFiles(folderPath))
        {
            var fileName = Path.GetFileName(f);
            FileSystem.RenameFile(f, "IMG-" + fileName);
        }
    }

    public void AddMusicTagForAllFiles(string folderPath)
    {
        foreach (var f in Directory.GetFiles(folderPath))
        {
            var fileName = Path.GetFileName(f);
            FileSystem.RenameFile(f, "AUDIO-" + fileName);
        }
    }
}
```

*Корректный код:*
```
class Some
{
    public void AddImgTagForAllFiles(string folderPath)
    {
        AddTagForAllFiles(folderPath, "IMG-");
    }

    public void AddMusicTagForAllFiles(string folderPath)
    {
        AddTagForAllFiles(folderPath, "AUDIO-");
    }

    void AddTagForAllFiles(string folder, string tag)
    {
        foreach (var f in Directory.GetFiles(folder))
        {
            var fileName = Path.GetFileName(f);
            FileSystem.RenameFile(f, tag + fileName);
        }
    }
}
```

#### Спагетти-код (Spaghetti code)

Спагетти-код — слабо структурированная и плохо спроектированная система, запутанная и очень сложная для понимания. Подобный код в будущем не сможет разобрать даже его автор. В таком коде очень легко допустить ошибку и очень сложно ее найти и внести какие-либо правки в принципе. В ООП спагетти-код может быть представлен в виде метода огромного по размеру. 

**Пример:**

*Некорректный код:*
```
class Some
{
    public bool AddGreenIfMoonAndNightOrAddSmith(
                    string name, bool ignoreMoon)
    {
        int moonPhase = 0;
        var planetsPhases = Web.GetPlanetsPhases();
        if (planetsPhases.Venus == 3)
        {
            if (planetsPhases.Mars == 4)
                moonPhase = 1;
            else if (planetsPhases.Jupiter == 1)
                moonPhase = 3;
            else
                moonPhase = 0;
        }
        else if (planetsPhases.Pluto > 3)
            moonPhase = 7;

        if (moonPhase == 0)
        {
            var intensity = Web.GetSunIntensity();
            if (intensity > 5000)
                moonPhase = 2;
        }

        if (moonPhase == 0)
            moonPhase = 4;

        var time = DateTime.Now;
        var today = DateTime.Today;
        var monthCoef = today.Month % 6 * today.Month / 6;
        var dayCoef = today.Day * 10;

        if (monthCoef > 5 && today.Year == 2001)
            dayCoef = 4;
        if (dayCoef > 7 || today.Year % 100 == 15)
            monthCoef = monthCoef * 0.7 + 1;
        else if (monthCoef < 2)
            monthCoef = monthCoef * 0.3;
        else
            monthCoef += 5;

        if (monthCoef*dayCoef+today.Year*1.05 < time.Hour
                && (moonPhase == 3 || ignoreMoon))
            name += "Green";
        else
            name += "Smith";
    }
}
```

*Корректный код:*
```
class Some
{
    public bool AddGreenIfMoonAndNightOrAddSmith(
                     string name, bool ignoreMoon)
    {
        var moonPhase = GetMoonPhase();
        var sunset = GetTodaySunsetTime();

        if (sunset < DateTime.Now.Hour 
            && (moonPhase == 3 || ignoreMoon))
            name += "Green";
        else
            name += "Smith";
    }
    
    int GetMoonPhase()
    {
        int moonPhase = 0;
        var planetsPhases = Web.GetPlanetsPhases();
        if (planetsPhases.Venus == 3)
        {
            if (planetsPhases.Mars == 4)
                moonPhase = 1;
            else if (planetsPhases.Jupiter == 1)
                moonPhase = 3;
            else
                moonPhase = 0;
        }
        else if (planetsPhases.Pluto > 3)
            moonPhase = 7;

        if (moonPhase == 0)
        {
            var intensity = Web.GetSunIntensity();
            if (intensity > 5000)
                moonPhase = 2;
        }

        if (moonPhase == 0)
            moonPhase = 4;

        return moonPhase;
    }

    int GetTodaySunsetTime()
    {
        var time = DateTime.Now;
        var today = DateTime.Today;
        var monthCoef = today.Month % 6 * today.Month / 6;
        var dayCoef = today.Day * 10;

        if (monthCoef > 5 && today.Year == 2001)
            dayCoef = 4;
        if (dayCoef > 7 || today.Year % 100 == 15)
            monthCoef = monthCoef * 0.7 + 1;
        else if (monthCoef < 2)
            monthCoef = monthCoef * 0.3;
        else
            monthCoef += 5;

        return monthCoef * dayCoef + today.Year * 1.05;
    }
}
```

#### Магические числа (Magic numbers)

Магическое число — не объявленное число, использованная в коде для чего-либо. Само число не несёт никакого смысла без соответствующего комментария или имени. Программист, который не является автором такого кода, порой с трудом может понять значение этого числа, если оно не очевидно. Со временем об этом забывает и сам автор. Такие числа затрудняют понимание кода и его рефакторинг. 

**Пример:**

*Некорректный код:*
```
class Some
{
    byte[] ReadImageFromTxtFile(string path)
    {
        var imageSize = fileStream.Length - 8;

        var fileStream = File.OpenRead(path);
        var result = new byte[imageSize];

        fileStream.Read(result, 8, imageSize);

       return result;
    }
}

```

*Корректный код:*
```
class Some
{
    byte[] ReadImageFromTxtFile(string path)
    {
        //Файл начинается с даты создания
        //в формате ddMMyyyy
        var offset = 8;

        var imageSize = fileStream.Length - offset;

        var fileStream = File.OpenRead(path);
        var result = new byte[imageSize];

        fileStream.Read(result, offset, imageSize);

       return result;
    }
}

```

#### Жёсткое кодирование (Hard code)

Жёсткое кодирование — внедрение различных данных об окружении в реализацию. Например: различные пути к файлам, имена процессов, устройств и так далее. Главная опасность, исходящая от этого анти-паттерна — непереносимость. 

**Пример:**

*Некорректный код:*
```
class Some
{
    void Do()
    {
        var file = @"C:\Program Files\Current Programm\Documents\Secret\1.txt";
        
        ...
    }
}
```

*Корректный код:*
```
class Some
{
    void Do()
    {
        var currentFolder = Directory.GetCurrentDirectory();
        var file = Path.Combine(currentFolder, @"Documents\Secret\1.txt");
        
        ...
    }
}
```

#### Ненужная сложность (Accidental complexity)

Ненужная сложность может быть внесена в решение любой задачи. Это могут быть, как ненужные проверки, части кода, так и просто странные конструкции или решения. Это приводит к усложнению понимания кода, а порой и к понижению скорости работы.

**Пример:**

*Некорректный код:*
```
class Some
{
    Animal GetAnimalType(string animal)
    {
        Animal res;
        if (animal.Length == 3 && animal == "cat")
            res = Animal.Cat;
        else if (animal.Length == 3 && animal == "dog")
            res = Animal.Dog;
        else if (animal.Length == 6 
                 && animal.Substring(0, 3) == "cat" 
                 && animal.Substring(3, 3) == "dog")
            res = Animal.CatDog;
        else
            res = Animal.Unknown;

        return res;
    }
}
```

*Корректный код:*
```
class Some
{
    Animal GetAnimalType(string animal)
    {
        Animal res;
        switch(animal)
        {
            case "cat":
                res = Animal.Cat;
                break;
            case "dog":
                res = Animal.Dog;
                break;
            case "catdog":
                res = Animal.CatDog;
                break;
            default:
                res = Animal.Unknown;
                break;
        }

        return res;
    }
}
```

#### Слепая вера (Blind faith)

Часто программист полагается на то, что его код будет вызван с определенно корректными входными данными или не спровоцирует ошибку в вызываемом коде. Из-за чего разработчик просто не проверяет данные на корректность или не обрабатывает ошибки. Все это приводит к тому, что изменения в другой части кода или непредусмотренное разработчиком поведение в реальной системе приводит к некорректной работе кода или и вовсе падению приложения. Но тут стоит быть осторожным, а не доводить проверки всего-всего до паранойи, иначе это приведет к анти-паттерну ненужной сложности.

**Пример:**

*Некорректный код:*
```
class Some
{
    bool FirstThreeLettersIsRUS (string str)
    {
        // следующая строка вызовет ошибку,
        // если str - NULL или короче 3 символов
        return str.Substring(0, 3) == "RUS";
    }
}
```

*Корректный код:*
```
class Some
{
    bool FirstThreeLettersIsRUS (string str)
    {
        return str != null
               && str.Length > 3
               && str.Substring(0, 3) == "RUS";
    }
}
```

#### Божественный объект (God Object)

Божественный объект —такой объект, который берет на себя слишком много функций и/или хранит в себе практически все данные. Иными словами, этот объект олицетворяет собой множество отдельных объектов. В итоге мы имеем непереносимый код, в котором, к тому же, сложно разобраться. Так же, подобный код довольно сложно поддерживать, учитывая, что вся система зависит практически только от него. 

**Пример:**

*Некорректный код:*
```
class GodObj
{
    int CountOfStarInTheSky = int.MaxValue;

    int ComputeIntegral(Expression exp) { }

    string[] SearchInGoogle(string param) { }

    Cookie[] MakeNymNym() { }
}
```

*Корректный код:*
```
class Astronimy
{
    int CountOfStarInTheSky = int.MaxValue;
}

class Math
{
    int ComputeIntegral(Expression exp) { }
}

class Google
{
    string[] Search(string param) { }
}

class CookieMonster
{
    Cookie[] MakeNymNym() { }
}
```

#### Лодочный якорь (Boat anchor)

Часто, после рефакторинга, некоторые части кода остаются в системе, хотя они уже больше не используются. Так же некоторые части кода могут быть оставлены «на будущее», авось еще пригодится. Такой код только усложняет проект, не неся абсолютно никакой практической ценности. Основная проблема заключается в том, что абсолютно весь код (даже неиспользуемый) необходимо поддерживать. Внесение изменений в код, который использует «мертвый-код», приводит к необходимости вносить изменения и в последнем – а это пустая трата ресурса.

#### Программирование перебором (Programming by permutation)

Многие начинающие программисты пытаются решать некоторые задачи методом перебора - подбирая параметры или порядка вызова функций, при котором этот код начинает работать. Все эти приводит к тому, что код работает лишь в определенном случае, а для всех остальных он дает не верный результат – т.е. по сути программист зная о баге, не решает его, а оставляет в проекте. 


Если вы будете избегать описанных выше моделей кода, то уже почти всегда ваш код можно будет покрыть тестами. Но, чтобы вашу работу наверняка с легкостью можно было протестировать, следует рассмотреть еще несколько анти-патернов.

### Убийцы тестов

Анти-патерны представленные в этом абзаце, вредны только для последующего тестирования. При их использовании, ваш код так же останется грамотно написанным, читаемым и работоспособным, вы лишь с большим трудом сможете написать для него тесты (или и вовсе не сможете). Так же, стоит учесть, что в некоторых случаях, без данных моделей и вовсе нельзя обойтись. Но все таки, стоит стараться изначально их избегать.

#### Добыча знаний

Добыча знаний происходит, когда метод требует один набор аргументов, но не использует их напрямую, а начинает «ковырять» эти аргументы в поисках других объектов. Типичные сценарии:
-	метод гуляет по объекту больше чем через одну точку.
-	метод не использует напрямую свой аргумент (использует его для получения другой информации)

Метод или конструктор должен требовать то, что ему реально нужно для работы. Он не должен сам заботиться о том, как все это получить/вычислить, выполняя какую либо работу. Нужно требовать минимально необходимый набор аргументов, для своей работы. Например: когда в магазине у вас просят заплатить за покупку, что вы делаете: даете кошелек, чтобы кассир сам взял оттуда деньги, или вы даете деньги? Думаю, аналогия понятна — класс кассир должен требовать на вход метода расчета класс деньги, а не класс кошелек.

Использование этого патерна приводит к тому, что в коде теста, при создании необходимого для класса объекта, вам так же необходимо его заполнить тестовыми данными. А так же, если код начинает искать данные из окружения (например, искать какие-либо запись в БД по идентификатору), то подготовить для теста и окружение. Все это в результате усложняет тестирование, заставляет лишний раз в пустую тратить ресурсы разработчика. 

**Пример:**

*Некорректный код:*
```
class DiscountCard
{
    DiscountCard(UserContext userContext)
    {
        this.user = userContext.getUser();
        this.level = userContext.getLevel();
        this.order = userContext.getOrder();
    }

    // ...
}

// тесты:
UserContext userContext = new UserContext();
userContext.setUser(new User("Ivan"));
PlanLevel level = new PlanLevel(143, "yearly");
userContext.setLevel(level);
Order order = new Order("SuperDeluxe", 100, true);
userContext.setOrder(order);
var card = new DiscountCard(userContext);
```

*Корректный код:*
```
class DiscountCard
{
    DiscountCard(User user, PlanLevel level, Order order)
    {
        this.user = user;
        this.level = level;
        this.order = order;
    }

    // ...
}

// тесты:
User user = new User("Ivan");
PlanLevel level = new PlanLevel(143, "yearly");
Order order = new Order("SuperDeluxe", 100, true);
var card = new DiscountCard(user, level, order);
```

#### Оператор new в бизнес коде

Классы, содержащие new в конструкторе абсолютно невозможно протестировать, потому что вызов почти любого метода приведет к вызову зависимостей, созданных внутри класса, а их мы не контролируем. Если они общаются с БД или шлют запросы в сеть, то тесты обречены. У нас нет совершенно никакой возможности подменить эти зависимости и изменить их поведение.

Класс должен требовать в конструктор все, что ему необходимо для работы. И его не волнует, откуда это там появится. Любой бизнес класс должен требовать готовые экземпляры своих зависимостей себе в конструктор - это главный принцип.

Исключение составляю классы, которые не содержат поведение. Например, array. Такие объекты класс имеет право создавать самостоятельно.

**Пример:**

*Некорректный код:*
```
class House
{
    Kitchen kitchen;
    Bedroom bedroom = new Bedroom();

    House()
    {
        this.kitchen = new Kitchen(
                             new Refrigerator());
    }

    // ...
}

// тесты:

House house = new House();    
// как дальше это тестировать?? 0_о 
```

*Корректный код:*
```
class House
{
    Kitchen kitchen;
    Bedroom bedroom = new Bedroom();

    House(Kitchen kitchen, Bedroom bedroom)
    {
        this.kitchen = kitchen;
        this.bedroom = bedroom;
    }

    // ...
}

// тесты:
Kitchen mockKit = new MockKitchen();
Bedroom mockBed = new MockBedroom();
House house = new House(mockKit, mockBed);
```

#### Статические классы, глобальные переменные и синглтоны.

Статические классы (аналогично глобальным переменным и синглтонам) имеют примерно тот же недостаток, что и скрытый внутри класса оператор new – реализацию их методов нельзя подменить, а это значит, что объект, который их использует может быть не всегда тестируемым (например, если статический класс в своем методе будет делать веб-запрос).  Поэтому стоит избегать создания статических классов\глобальных переменных\синглтонов.

Стоит учесть такой момент, что порой попытки сделать класс тестируемым приводит к ухудшению производительности. И здесь стоит балансировать между тем, что для вас критичнее: производительность или покрытие кода.



### Заключение
Если вы планируете разрабатывать долгосрочный проект, который будет развиваться и расти – обязательно пишите для него тесты. При внесении изменений в большой проект, никогда нельзя быть уверенным, что в этот момент что-то не сломалось в другой части приложения. Иногда это очень маленькая мелочь, которая месяцами может оставаться не обнаруженной. Тесты же не дают появится таким скрытым багам, сразу предупреждая разработчика, что его изменения преобразовали поведение где-то еще. Если ваш проект покрыт тестами, которые постоянно выполняются – вы можете быть уверены, что ваш проект работает исправно и отвечает всем предъявленным к нему требованиям.
