# Доклад
Алгоритмы сглаживания полигональных моделей. Проблема уменьшения объема.
========================================================================
## Введение
#### Полезный подход для получения сложных геометрических моделей в компьютерной графике - это оцифровывание. Из облака точек, полученного со сканирующих устройств, таких как лазерный сканнер или тактильный сканнер, описание поверхности может быть получено соединением точек определенным образом в полигональную сетку или набор треугольников

#### К сожалению оцифрованные точки не всегда отражают корректное расположение на реальной поверхности из-за физического шума, добавленного сканирующим устройством. Вследствие этого реконструированная поверхность зачастую выглядит неудовлетворительно. Следовательно, полигональная модель должна быть сглажена для того, чтобы устранить шум.

Основная часть
--------------
### Алгоритм Лапласа
#### Один из подходов к сглаживанию - это алгоритм Лапласа. Версии алгоритма сглаживания Лапласа известны в обработке изображений и в методе конечных элементов. Основная идея в обработке изображений - это заменить значение пикселя на среднее значение пикселей по соседству. Аналогично, расположение вершин полигональной модели в методе конечных элементов корректируется путем вычисления нового положения как среднего всех координат соседствующих вершин.

![GitHub Logo](./Images/Laplacian algorithm.jpg)

### V<sub>*var*</sub> - набор подвижных точек, V<sub>*fix*</sub> - набор неподвижных точек, q<sub>*i,j*</sub> - текущие неподвижные точки, p<sub>*i*</sub> - текущая подвижная точка, adj(i) - прилегающие точки.

### Этот процесс может применяться итеративно, пока результат не будет удовлетворительным

#### Усреднение дает именно тот эффект, который нужен нам для сглаживании полигональной модели. Однако он имеет побочный эффект: при большом числе итераций модель начинает сокращаться в размерах.
![GitHub Logo](./Images/Shrinkage2.jpg)

### Включение центральной точки

#### Можно заметить, что в расчет позиции точки p<sub>*i*</sub> включены только позиции прилегающих точек без позиции текущей точки q<sub>*i*</sub>. Если включить и ее в расчет, то система примет вид:

![GitHub Logo](./Images/central point equasion.jpg)

#### Однако это не сильно помогает. Оказывается, включение центральной точки в расчет не производит никаких положительных эффектов ни на качество сглаживания, ни на степень сокращения. Эта можификация лишь задерживает процесс сглаживания.

### Включение исходной точки

#### В общем случае алгоритм лапласа может не сходиться. Рассмотрим модель, состоящую всего из двух вершин i, j, соединенных одним ребром {i, j}. Оригинальный алгоритм Лапласа обменивается позициями p<sub>*i*</sub> и p<sub>*j*</sub> попеременно. Но в большинстве случаев модель сходится в одну точку.

#### Чтобы избежать этих недостатков нужно включить в расчет исходные точки o<sub>*i*</sub>

![GitHub Logo](./Images/original point equasion.jpg)

#### В зависимости от коэффициента α (0 < α < 1) мы можем выбрать между сильной и слабой связью точки i с изначельной позицией o<sub>*i*</sub>.

### HC-Алгоритм

#### HC-алгоритм предотвращает сокращение объема, сохраняя при этом эффект сглаживания. На рисунке показан результат применения этого алгоритма. Можно заметить, что сглаженная модель соответствует оригинальной не только по форме, но и по размеру.

![GitHub Logo](./Images/Shrinkage3.jpg)

#### Идея заключается в том, чтобы сдвинуть измененные точки p<sub>*i*</sub>, полученные в каждом шаге алгоритма Лапласа, обратно в направлении предыдущих точек q<sub>*i*</sub> и исходных точек o<sub>*i*</sub> на среднее значение разности:

![GitHub Logo](./Images/HC-picture.jpg).

#### Оказывается, что в этом случае разница b<sub>*i*</sub> в центре вершины i должна быть включена с коэффициентом β (0 < β < 1) так, что

![GitHub Logo](./Images/di equasion.jpg).

#### На изображении показан куб, к которому был добавлен случайный шум и который был впоследствии сглажен алгоритмом Лапласа.

![GitHub Logo](./Images/Laplacian cube.jpg).

#### Можно заметить, что куб заметно сократился в объеме.

![GitHub Logo](./Images/HC-algorithm code.jpg).

#### На рисунке тот же "шумный" куб, сглаженный уже HC-алгоритмом. Для сравнения на картинке показаны результаты применения обоих алгоритмов попеременно (слева-направо).

![GitHub Logo](./Images/HC-algorithm cube.jpg).

### Алгоритм Гаусса

#### В методе сглаживания Гаусса новые координаты вершины вычисляются как среднее взвешенное координат самой вершины и ее соседей первого порядка: вершины, которые входят в состав одного и того же ребра или грани, которые содержат текущую вершину. Этот процесс повторяется несколько раз.

#### У алгоритма Гаусса есть ряд преимуществ по сравнению с другими алгоритмами:
#### 1. Применяется по кускам к линейным поверхностям произвольной топологии, а не только к тем, которые могут быть параметризованы функциями, определенными на прямоугольной области.
#### 2. Так как соседи первого порядка определены неявным образом в списке ребер или граней поверхности, то не требуется отводить дополнительное пространство для кодирования соседних структур.
#### 3. Количество операций - это линейная функция от количества граней, ребер и вершин.

#### Однако, так как этот метод локален, то для получения сглаживающего эффекта необходимо применять алгоритм итеративно множество раз. Побочный эффект от этого - сокращение размеров модели.

#### Замкнутый многоугольник в двух или трех измерениях обычно представлен в виде упорядоченного списка вершин V = {v<sub>i</sub> : 1 ≤ i ≤ n<sub>V</sub>}, где v<sub>i</sub> = (x<sub>i</sub>, y<sub>i</sub>)<sup>t</sup> или v<sub>i</sub> = (x<sub>i</sub>, y<sub>i</sub>, z<sub>i</sub>)<sup>t</sup>, для двухмерной и трехмерной кривой соответственно. Никакой дополнительной информации не требуется, так как кривые имеют свойственную им линейную упорядоченность. Но для разомкнутой кривой или кривой, состоящей из нескольких соединенных компонентов желательно представление в виде пар списков C = {V, E}, где V - список вершин, а E = {e<sub>k</sub> : 1 ≤ k ≤ n<sub>E</sub>} - список ребер, где каждое ребро e<sub>k</sub> = (i<sub>1</sub><sup>k</sup>, i<sub>2</sub><sup>k</sup>) является парой неповторяющихся индексов вершин. Поверхнось обычно представлена в виде пары списков C = {V, F}, где V - список вершин, а F = {f<sub>k</sub> : 1 ≤ k ≤ n<sub>F</sub>} - список граней, где каждая грань f<sub>k</sub> = (i<sub>1</sub><sup>k</sup>,..., i<sup>k</sup><sub>n<sub>f<sub>k</sub></sub></sub>) - это последовательность неповторяющихся индексов вершин и по сути является замкнутым, не обязательно плоским многоугольником в трехмерном пространстве. В некоторых случаях количество граней n<sub>f<sub>k</sub></sub> изменяется от грани к грани, тогда как в других случаях все грани имеют одинаковое количество вершин. Триангулированные поверхности, где все грани - это треугольники f<sub>k</sub> = (i<sub>1</sub><sup>k</sup>, i<sub>2</sub><sup>k</sup>, i<sub>3</sub><sup>k</sup>) является самыми распространенными.

#### *Область* вершины v<sub>i</sub> - это набор индексов вершин i<sup>\*</sup>. Если индекс j принадлежит области i<sup>\*</sup>, то говорят, что v<sub>j</sub> - сосед v<sub>i</sub>. Ни одна вершина не должна быть своим же соседом. Допускается, что если v<sub>j</sub> - сосед v<sub>i</sub>, то v<sub>i</sub> может не быть соседом v<sub>j</sub>. Если эта ситуация не наблюдается, то структура области является *симметричной*. *Структура области* фигуры определена семейством всех областей {i<sup>\*</sup> : i = 1, 2,...,n<sub>V</sub>}. Особенно важной структурой области является структура области *первого порядка*, где для каждой пары вершин v<sub>i</sub> и v<sub>j</sub>, которые входят в состав ребра или грани, верно, что они являются соседями по отношению друг к другу. Структура области первого порядка является симметричной и, так как она неявно представлена в списке вершин, ребер или граней фигуры, то не требуется дополнительной памяти для ее хранения.

#### Алгоритм Гаусса заменяет позицию каждой вершины выпуклой комбинацией позиций самой же точки и ее соседей. Сначала, для каждой вершины v<sub>i</sub>, считается среднее вектора:

### Δv<sub>i</sub> = <span style="font-size: 2em">Σ</span> w<sub>ij</sub>(v<sub>j</sub> - v<sub>i</sub>)

#### Это взвешенное среднее векторов v<sub>j</sub> - v<sub>i</sub>, которые отходят от текущей вершины v<sub>i</sub> к соседней вершине v<sub>j</sub>. Для каждой вершины w<sub>ij</sub> - положительное число, которое равно 1/|i<sup>\*</sup>|, где i<sup>\*</sup> - это область вершины v<sub>i</sub>. Когда все средние векторов посчитаны, вершины обновляются путем добавления соответствующего вектора смещения к текущей позиции каждой вершины v<sub>i</sub>: <p>v<sub>i</sub>' = v<sub>i</sub> + λΔv<sub>i</sub> <p> где λ - масштабный коэффициент, v<sub>i</sub>' - новое положение вершины. λ - положительное число 0 < λ < 1, которое может быть одинаково для всех вершин или быть зависимым от каждой вершины.

### Алгоритм Таубина

#### Алгоритм состоит из двух последовательных этапов алгоритма Гаусса. После первого этапа сглаживания с положительным масштабным коэффициентом λ, следует второй этап, но уже с отрицательным масштабным коэффициентом μ, который превосходит λ по абсолютному значению (0 <  λ < -μ). Для того, чтобы получить значительный эффект сглаживания, эти шаги должны быть применены несколько раз.

#### На самом деле, этот метод производит эффект фильтра нижних частот, когда кривая, или кривизна поверхности принимается за частоту.

## Сравнение алгоритмов

#### □ - алгоритм Таубина. o - алгоритм лапласа.

![GitHub Logo](./Images/Sphere.jpg).

![GitHub Logo](./Images/Simple graph.jpg).

![GitHub Logo](./Images/Rose.jpg).

![GitHub Logo](./Images/Complex graph.jpg).

## Используемая литература:

### 1. Gabriel Taubin. Curve and surface smoothing without shrinkage. Technical Report RC-19536, IBM Research, April 1994.

### 2. J. Vollmer, R. Mencl, and H. Müller. Improved Laplacian Smoothing of Noisy Surface Meshes, 1999.

### 3. Alexander Belyaev. A Comparison of Mesh Smoothing Methods.
